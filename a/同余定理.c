#include<stdio.h>
#include<math.h>
 
#define Max 100
int x,num;
int m;
 
void init()
{
	printf("请输入x的num次幂：");
	scanf("%d%d",&x,&num);
	printf("请输入模：");
	scanf("%d",&m);
}
 
void function(int x,int num,int m)
{
	int i = 0,j=0;
	int r = 0;
	int a[Max];
	while(1)
	{
		r = (int)(pow(x,i+1)) % m;
		a[i] = r;
		i++;
		if(r == 1)
			break;
	}
	printf("%d 的 %d 次幂模 %d 的余数为：%d\n",x,num,m,a[num % i -1]);
} 
 
 
//*****************此方法仅用来总结规律不用于计算***********************
//不用计算两个数的乘积，可以转化位分别求出1992÷7和59÷7的余数的积，使计算简单化。
//第一个余数是4，第二个余数是3.余数的乘积是12，除以7后的余数是5，所以1992×59除以7的余数是5.
//简单记做因为1992×59≡4×3≡5（mod7）,所以余数是5.
 
void lj(int x,int num,int m)
{
	int i=0;
	int r=0;
	int a[Max];
	while(i<6)  //i限制为6主要是因为幂指数过大会有内存溢出，次lj函数只是为了找规律
	{
		r = (int)(pow(x,i+1)) % m;
		printf("%d的%d次幂对%d取余数为：%d\n",x,(i+1),m,r);
		a[i] = r;
		i++;
	}
}
 
/*
测试结果：
	请输入x的num次幂：16 200（用16的200次幂对21求余数）
	请输入模：21
	a[0]:	16的1次幂对21取余数为：16
	a[1]:	16的2次幂对21取余数为：4	16的2次幂对21取余数等于16的1次幂对21取余数（16）*16的1次幂对21取余数（16） = 16*16 % 21 = 256 % 21 = 4 
	a[2]:	16的3次幂对21取余数为：1	16的3次幂对21取余数等于16的2次幂对21取余数（16）*16的1次幂对21取余数（16） = 4*16 % 21 = 64 % 21 = 1 
	a[3]:	16的4次幂对21取余数为：16
	a[4]:	16的5次幂对21取余数为：4
	a[5]:	16的6次幂对21取余数为：1	
		因此总结得出规律x的num次幂对m取余数可以先找出前n个，然后用 num % n 求出的余数即代表第几个余数
*/
 
//****************************************************************************
 
 
int main()
{
	init();
 
	function(x,num,m);
 
	return 0;
}